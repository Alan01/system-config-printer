#!/usr/bin/python
# -*- python -*-

## Copyright (C) 2009 Red Hat, Inc.
## Author: Tim Waugh <twaugh@redhat.com>

## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.

## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

import sys

import cups
from getopt import getopt
import os
import posix
import re
import shlex
import signal
import stat
import subprocess
import sys
import tempfile

class TimedOut(Exception):
    def __init__ (self):
        Exception.__init__ (self, "Timed out")

class DeviceIDs:
    def __init__ (self):
        self.ids = dict()

    def get_dict (self):
        return self.ids

    def get_tags (self):
        ret = []
        def squash(x):
            r = x.lower ()
            for a in [' ', '(', ')']:
                r = r.replace (a, '_')

            return r

        for mfg, mdlset in self.ids.iteritems ():
            mfgsquash = squash (mfg)
            for mdl in mdlset:
                mdlsquash = squash (mdl)
                ret.append ("postscriptdriver(%s;%s;)" % (mfgsquash,
                                                          mdlsquash))

        return ret

    def __add__ (self, other):
        if isinstance(other, DeviceIDs):
            for omfg, omdlset in other.ids.iteritems ():
                try:
                    mdlset = self.ids[omfg]
                except KeyError:
                    mdlset = set()
                    self.ids[omfg] = mdlset

                mdlset.update (omdlset)

            return self

        pieces = other.split (';')
        mfg = mdl = None
        for piece in pieces:
            s = piece.split (":")
            if len (s) != 2:
                continue
            key, value = s
            key = key.upper ()
            if key in ["MFG", "MANUFACTURER"]:
                mfg = value
            elif key in ["MDL", "MODEL"]:
                mdl = value

        if mfg and mdl:
            try:
                mdlset = self.ids[mfg]
            except KeyError:
                mdlset = set()
                self.ids[mfg] = mdlset

            mdlset.add (mdl)

        return self

class Driver:
    def __init__ (self):
        self.ids = DeviceIDs()

    def list (self):
        return self.ids

class PPDDriver(Driver):
    def __init__ (self, pathname=None):
        Driver.__init__ (self)
        self.pathname = pathname

    def list (self):
        if self.pathname != None:
            self.examine_file (self.pathname)

        return Driver.list (self)

    def examine_file (self, path):
        try:
            ppd = cups.PPD (path)
        except RuntimeError, e:
            # Not a PPD file.  Perhaps it's a drv file.
            drv = DrvDriver (path)
            self.ids += drv.list ()
            return

        attr = ppd.findAttr ('1284DeviceID')
        if attr:
            self.ids += attr.value

class DynamicDriver(Driver):
    def __init__ (self, driver):
        Driver.__init__ (self)
        self.driver = driver
        signal.signal (signal.SIGALRM, self._alarm)

    def _alarm (self, sig, stack):
        raise TimedOut

    def list (self):
        signal.alarm (60)
        p = subprocess.Popen ([self.driver, "list"],
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE)
        try:
            (stdout, stderr) = p.communicate ()
            signal.alarm (0)
        except TimedOut:
            posix.kill (p.pid, signal.SIGKILL)
            raise

	if stderr:
		print >> sys.stderr, stderr

	ppds = []
	lines = stdout.split ('\n')
	for line in lines:
		l = shlex.split (line)
		if len (l) < 5:
                    continue
                self.ids += l[4]

        return Driver.list (self)

class DrvDriver(PPDDriver):
    def __init__ (self, pathname):
        PPDDriver.__init__ (self)
        self.drv = pathname

    def _alarm (self, sig, stack):
        raise TimedOut

    def list (self):
        tmpdir = os.environ.get ("TMPDIR", "/tmp") + os.path.sep
        outputdir = tempfile.mkdtemp (dir=tmpdir)
        
        argv = [ "ppdc",
                 "-d", outputdir,
                 "-I", "/usr/share/cups/ppdc",
                 self.drv ]

        signal.alarm (60)
        p = subprocess.Popen (argv,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE)
        try:
            (stdout, stderr) = p.communicate ()
            signal.alarm (0)
        except TimedOut:
            posix.kill (p.pid, signal.SIGKILL)
            raise

        os.path.walk (outputdir, self.examine_directory, None)
        os.rmdir (outputdir)
        return Driver.list (self)

    def examine_directory (self, unused, dirname, fnames):
        for fname in fnames:
            path = dirname + os.path.sep + fname
            self.examine_file (path)
            os.unlink (path)

class TagBuilder:
    def __init__ (self, filelist=None):
        if filelist == None:
            filelist = sys.stdin

        self.ids = DeviceIDs ()
        while True:
            path = filelist.readline ()
            if path == '':
                break

            path = path.rstrip ()
            st = os.stat (path)
            if not stat.S_ISREG (st.st_mode):
                continue

            if (path.find ("/usr/share/cups/model/") != -1 or
                path.find ("/usr/share/ppd/") != -1 or
                path.find ("/usr/share/cups/drv/") != -1):
                self.ids += PPDDriver (path).list ()
            elif path.find ("/usr/lib/cups/driver/") != -1:
                self.ids += DynamicDriver (path).list ()

    def get_tags (self):
        return self.ids.get_tags ()

if __name__ == "__main__":
    builder = TagBuilder ()
    tags = builder.get_tags ()
    for tag in tags:
        print tag
